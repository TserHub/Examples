<!DOCTYPE html>
<html>

<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="renderer" content="webkit" />
  <meta name="force-rendering" content="webkit" />
  <meta name="google" value="notranslate" />

  <title>window.localStorage</title>

</head>

<body>
  <script>
    window.localStorage.clear(); // 清除所有保存的数据。该方法的返回值是undefined。

    // 写入的三种方法
    setTimeout(() => {
      window.localStorage.setItem('one', 'a'); // 接受两个参数:键名，键值。若键名已经存在，更新已有的键值。该方法没有返回值。
    }, 1000);
    setTimeout(() => {
      window.localStorage.two = 'b';
    }, 2000);
    setTimeout(() => {
      window.localStorage['three'] = 'c';
    }, 3000);

    // 读取数据
    setTimeout(() => {
      window.localStorage.setItem('foo', 'bar');
      console.log(window.localStorage.getItem('foo')); // 读取数据。参数：键名。如果键名不存在，该方法返回null。
    }, 4000);

    // 移除数据
    setTimeout(() => {
      window.localStorage.removeItem('foo'); // 清除某个键名对应的键值。它接受键名作为参数，如果键名不存在，该方法不会做任何事情。
    }, 5000);

    // 注意，该事件不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。
    window.addEventListener('storage', (e) => {
      const { key, newValue, oldValue, storageArea, url } = e;
      console.log(storageArea);
      console.log(key, newValue, oldValue, url);
      // const len = window.localStorage.length;
      // console.log('len:', len);
      /* for(let i = 0; i < len; i++) {
        const key = window.localStorage.key(i);
        console.log(`${key}:${window.localStorage[key]}`); // key()接受一个整数作为参数（从零开始），返回该位置对应的键值。
      } */
    });
  </script>
</body>

</html>
